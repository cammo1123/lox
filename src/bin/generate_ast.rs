use std::{env, fs::File, io::Write, process::exit};
use std::collections::HashSet;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: generate_ast_enum <output directory>");
        exit(64);
    }
    let out = &args[1];

    generate(out, "expr", &vec![
        "Assign   : Token name, Expr value",
        "Binary   : Expr left, Token operator, Expr right",      
        "Call     : Expr callee, Token paren, Vec<Expr> arguments",
        "Grouping : Expr expression",
        "Literal  : Object value",
        "Logical  : Expr left, Token operator, Expr right",
        "Unary    : Token operator, Expr right",
        "Variable : Token name",
    ])?;

    generate(out, "stmt", &vec![
        "Block      : Vec<Stmt> statements",
        "Expression : Expr expression",
        "Function   : Token name, Vec<Token> params, Vec<Stmt> body",
        "If         : Expr condition, Stmt then_branch, Stmt else_branch",
        "Print      : Expr expression",
        "Return     : Token keyword, Expr value",
        "Var        : Token name, Expr initializer",
        "While      : Expr condition, Stmt body"
    ])?;

    Ok(())
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

fn extract_type_idents(s: &str) -> Vec<String> {
    let mut res = Vec::new();
    let bytes = s.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        let b = bytes[i];
        if b.is_ascii_uppercase() {
            let start = i;
            i += 1;
            while i < bytes.len() {
                let nb = bytes[i];
                if nb.is_ascii_alphanumeric() || nb == b'_' {
                    i += 1;
                } else {
                    break;
                }
            }
            res.push(s[start..i].to_string());
        } else {
            i += 1;
        }
    }
    res
}

fn generate(
    output_dir: &str,
    base_name: &str,
    types: &[&str],
) -> Result<(), Box<dyn std::error::Error>> {
    let path = format!("{}/{}.rs", output_dir, base_name);
    let mut f = File::create(&path)?;

    writeln!(f, "// GENERATED by generate_ast_enum.rs")?;

    // Collect type idents (Token, Object, Expr, Stmt, etc.)
    let base_type = capitalize_first(base_name);
    let mut idents: HashSet<String> = HashSet::new();

    // Always import InterpreterError for Visitor return type.
    idents.insert("InterpreterError".to_string());

    // Types we don't pull from crate.
    let prelude: &[&str] = &[
        "Box", "Vec", "Option", "Result", "String", "bool", "i32", "i64", "usize", "f32",
        "f64", "Rc", "Arc",
    ];

    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        if parts.len() < 2 {
            continue;
        }
        let fields = parts[1].trim();
        for field in fields.split(',') {
            let field = field.trim();
            if field.is_empty() {
                continue;
            }
            let ty = field.split_whitespace().next().unwrap();
            let found = extract_type_idents(ty);
            for id in found {
                if id == base_type {
                    continue;
                }
                if prelude.iter().any(|p| *p == id) {
                    continue;
                }
                idents.insert(id);
            }
        }
    }

    // Map well-known idents to crate module paths; fallback to lowercase module.
    fn map_to_module(ident: &str) -> String {
        match ident {
            "Object" => "object::Object".to_string(),
            "Token" => "token::Token".to_string(),
            "InterpreterError" => "error::InterpreterError".to_string(),
            other => format!("{}::{}", other.to_lowercase(), other),
        }
    }

    let mut entries: Vec<String> =
        idents.into_iter().map(|i| map_to_module(&i)).collect();
    entries.sort();

    if !entries.is_empty() {
        writeln!(f, "use crate::{{{}}};", entries.join(", "))?;
    }
    writeln!(f, "use std::fmt::Debug;")?;
    writeln!(f)?;

    // Enum
    writeln!(f, "#[derive(Debug, Clone)]")?;
    writeln!(f, "pub enum {} {{", base_type)?;
    writeln!(f, "    Nil,")?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let fields = parts[1].trim();

        write!(f, "    {} {{ ", name)?;
        let field_list: Vec<&str> = fields.split(',').map(|s| s.trim()).collect();
        for (i, field) in field_list.iter().enumerate() {
            let mut it = field.split_whitespace();
            let ty = it.next().unwrap();
            let nm = it.next().unwrap();
            let rust_ty = if ty == base_type {
                format!("Box<{}>", base_type)
            } else {
                ty.to_string()
            };
            write!(f, "{}: {}", nm, rust_ty)?;
            if i + 1 != field_list.len() {
                write!(f, ", ")?;
            }
        }
        writeln!(f, " }},")?;
    }
    writeln!(f, "}}")?;
    writeln!(f)?;

    // Visitor trait
    let base_lower = base_type.to_lowercase();
    writeln!(f, "pub trait Visitor<T> {{")?;
    writeln!(f, "    fn visit_null_{}(&mut self) -> Result<T, InterpreterError>;", base_lower)?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let fields = parts[1].trim();
        let fn_name = format!("visit_{}_{}", name.to_lowercase(), base_lower);
        write!(f, "    fn {}(&mut self", fn_name)?;
        let field_list: Vec<&str> = fields.split(',').map(|s| s.trim()).collect();
        for field in field_list {
            let mut it = field.split_whitespace();
            let ty = it.next().unwrap();
            let nm = it.next().unwrap();
            let param_ty = if ty == base_type {
                format!("&{}", base_type)
            } else {
                format!("&{}", ty)
            };
            write!(f, ", {}: {}", nm, param_ty)?;
        }
        writeln!(f, ") -> Result<T, InterpreterError>;")?;
    }
    writeln!(f, "}}")?;
    writeln!(f)?;

    // accept impl
    writeln!(f, "impl {} {{", base_type)?;
    writeln!(
        f,
        "    pub fn accept<T, V: Visitor<T>>(&self, visitor: &mut V) \
         -> Result<T, InterpreterError> {{"
    )?;
    writeln!(f, "        match self {{")?;
    writeln!(
        f,
        "            {}::Nil => visitor.visit_null_{}(),",
        base_type, base_lower
    )?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let fields = parts[1].trim();
        write!(f, "            {}::{} {{ ", base_type, name)?;
        let field_list: Vec<&str> = fields.split(',').map(|s| s.trim()).collect();
        for (i, field) in field_list.iter().enumerate() {
            let nm = field.split_whitespace().nth(1).unwrap();
            write!(f, "{}", nm)?;
            if i + 1 != field_list.len() {
                write!(f, ", ")?;
            }
        }
        write!(f, " }} => ")?;
        let fn_name = format!("visit_{}_{}", name.to_lowercase(), base_lower);
        write!(f, "visitor.{}(", fn_name)?;
        for (i, field) in field_list.iter().enumerate() {
            let mut it = field.split_whitespace();
            let ty = it.next().unwrap();
            let nm = it.next().unwrap();
            if ty == base_type {
                write!(f, "&*{}", nm)?;
            } else {
                write!(f, "&{}", nm)?;
            }
            if i + 1 != field_list.len() {
                write!(f, ", ")?;
            }
        }
        writeln!(f, "),")?;
    }
    writeln!(f, "        }}")?;
    writeln!(f, "    }}")?;
    writeln!(f, "}}")?;

    Ok(())
}