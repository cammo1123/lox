use std::{env, fs::File, io::Write, process::exit};
use std::collections::HashSet;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: generate_ast_enum <output directory>");
        exit(64);
    }
    let out = &args[1];

    generate(out, "expr", &vec![
        "Assign   : Token name, Expr value",
        "Binary   : Expr left, Token operator, Expr right",      
        "Call     : Expr callee, Token paren, Vec<Expr> arguments",
        "Grouping : Expr expression",
        "Literal  : Object value",
        "Logical  : Expr left, Token operator, Expr right",
        "Unary    : Token operator, Expr right",
        "Variable : Token name",
    ])?;

    generate(out, "stmt", &vec![
        "Block      : Vec<Stmt> statements",
        "Expression : Expr expression",
        "Function   : Token name, Vec<Token> params, Vec<Stmt> body",
        "If         : Expr condition, Stmt then_branch, Stmt else_branch",
        "Print      : Expr expression",
        "Return     : Token keyword, Expr value",
        "Var        : Token name, Expr initializer",
        "While      : Expr condition, Stmt body"
    ])?;

    Ok(())
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

fn extract_type_idents(s: &str) -> Vec<String> {
    let mut res = Vec::new();
    let bytes = s.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        let b = bytes[i];
        if b.is_ascii_uppercase() {
            let start = i;
            i += 1;
            while i < bytes.len() {
                let nb = bytes[i];
                if nb.is_ascii_alphanumeric() || nb == b'_' {
                    i += 1;
                } else {
                    break;
                }
            }
            res.push(s[start..i].to_string());
        } else {
            i += 1;
        }
    }
    res
}

fn generate(
    output_dir: &str,
    base_name: &str,
    types: &[&str],
) -> Result<(), Box<dyn std::error::Error>> {
    let path = format!("{}/{}.rs", output_dir, base_name);
    let mut f = File::create(&path)?;

    writeln!(f, "// GENERATED by generate_ast_enum.rs")?;

    // Collect type idents (Token, Object, Expr, Stmt, etc.)
    let base_type = capitalize_first(base_name);
    let mut idents: HashSet<String> = HashSet::new();

    // Always import InterpreterError for Visitor return type.
    idents.insert("InterpreterError".to_string());

    // Types we don't pull from crate.
    let prelude: &[&str] = &[
        "Box", "Vec", "Option", "Result", "String", "bool", "i32", "i64", "usize", "f32",
        "f64", "Rc", "Arc",
    ];

    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        if parts.len() < 2 {
            continue;
        }
        let fields = parts[1].trim();
        for field in fields.split(',') {
            let field = field.trim();
            if field.is_empty() {
                continue;
            }
            let ty = field.split_whitespace().next().unwrap();
            let found = extract_type_idents(ty);
            for id in found {
                if id == base_type {
                    continue;
                }
                if prelude.iter().any(|p| *p == id) {
                    continue;
                }
                idents.insert(id);
            }
        }
    }

    // Map well-known idents to crate module paths; fallback to lowercase module.
    fn map_to_module(ident: &str) -> String {
        match ident {
            "Object" => "object::Object".to_string(),
            "Token" => "token::Token".to_string(),
            "InterpreterError" => "error::InterpreterError".to_string(),
            other => format!("{}::{}", other.to_lowercase(), other),
        }
    }

    let mut entries: Vec<String> =
        idents.into_iter().map(|i| map_to_module(&i)).collect();
    entries.sort();

    if !entries.is_empty() {
        writeln!(f, "use crate::{{{}}};", entries.join(", "))?;
    }
    writeln!(f, "use std::fmt::Debug;")?;
    writeln!(f)?;

    // Variant struct definitions
    // Create a struct for Nil and for each variant; fields are `pub`.
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let fields = parts[1].trim();
        let struct_name = format!("{}{}", base_type, name);
        // If there are no fields (shouldn't happen with current inputs), emit empty braced struct.
        let field_list: Vec<&str> = fields.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
        writeln!(f, "#[derive(Debug, Clone, Eq, Hash, PartialEq)]")?;
        writeln!(f, "pub struct {} {{", struct_name)?;
        if field_list.is_empty() {
            // empty struct body
        } else {
            for field in &field_list {
                let mut it = field.split_whitespace();
                let ty = it.next().unwrap();
                let nm = it.next().unwrap();
                let rust_ty = if ty == base_type {
                    format!("Box<{}>", base_type)
                } else {
                    ty.to_string()
                };
                writeln!(f, "    pub {}: {},", nm, rust_ty)?;
            }
        }
        writeln!(f, "}}")?;
    }

    writeln!(f, "#[derive(Debug, Clone, Eq, Hash, PartialEq)]")?;
    writeln!(f, "pub struct {}Nil {{}}", base_type)?;
    writeln!(f)?;

    writeln!(f, "#[derive(Debug, Clone, Eq, Hash, PartialEq)]")?;
    writeln!(f, "pub enum {} {{", base_type)?;
    writeln!(f, "    Nil({}Nil),", base_type)?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let struct_name = format!("{}{}", base_type, name);
        writeln!(f, "    {}({}),", name, struct_name)?;
    }
    writeln!(f, "}}")?;
    writeln!(f)?;

    // impl From<VariantStruct> for Base so `.into()` works
    writeln!(f, "// convert variant structs into the enum with `.into()`")?;
    writeln!(f, "impl From<{}Nil> for {} {{", base_type, base_type)?;
    writeln!(f, "    fn from(val: {}Nil) -> Self {{", base_type)?;
    writeln!(f, "        {}::Nil(val)", base_type)?;
    writeln!(f, "    }}")?;
    writeln!(f, "}}")?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let struct_name = format!("{}{}", base_type, name);
        writeln!(f, "impl From<{}> for {} {{", struct_name, base_type)?;
        writeln!(f, "    fn from(val: {}) -> Self {{", struct_name)?;
        writeln!(f, "        {}::{}(val)", base_type, name)?;
        writeln!(f, "    }}")?;
        writeln!(f, "}}")?;
    }
    writeln!(f)?;

    // Visitor trait
    let base_lower = base_type.to_lowercase();
    writeln!(f, "pub trait Visitor<T> {{")?;
    writeln!(f, "    fn visit_null_{}(&mut self, expr: &{}Nil) -> Result<T, InterpreterError>;", base_lower, base_type)?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let struct_name = format!("{}{}", base_type, name);
        let fn_name = format!("visit_{}_{}", name.to_lowercase(), base_lower);
        writeln!(f, "    fn {}(&mut self, expr: &{}) -> Result<T, InterpreterError>;", fn_name, struct_name)?;
    }
    writeln!(f, "}}")?;
    writeln!(f)?;

    // accept impl
    writeln!(f, "impl {} {{", base_type)?;
    writeln!(
        f,
        "    pub fn accept<T, V: Visitor<T>>(&self, visitor: &mut V) \
         -> Result<T, InterpreterError> {{"
    )?;
    writeln!(f, "        match self {{")?;
    writeln!(
        f,
        "            {}::Nil(nil) => visitor.visit_null_{}(nil),",
        base_type, base_lower
    )?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        writeln!(
            f,
            "            {}::{}(inner) => visitor.visit_{}_{}(inner),",
            base_type,
            name,
            name.to_lowercase(),
            base_lower
        )?;
    }
    writeln!(f, "        }}")?;
    writeln!(f, "    }}")?;
    writeln!(f, "}}")?;

    Ok(())
}