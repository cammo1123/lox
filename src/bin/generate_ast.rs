use std::{env, fs::File, io::Write, process::exit};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: generate_ast_enum <output directory>");
        exit(64);
    }
    let out = &args[1];

    // Provide types in the same compact format you used earlier.
    let types = vec![
        "Binary   : Expr left, Token operator, Expr right",
        "Grouping : Expr expression",
        "Literal  : Object value",
        "Unary    : Token operator, Expr right",
    ];

    generate(out, "expr", &types)?;
    Ok(())
}

fn generate(output_dir: &str, base_name: &str, types: &[&str]) -> Result<(), Box<dyn std::error::Error>> {
    let path = format!("{}/{}.rs", output_dir, base_name);
    let mut f = File::create(&path)?;

    writeln!(f, "// GENERATED by generate_ast_enum.rs")?;
    writeln!(f, "use crate::token::Token;")?;
    writeln!(f, "use std::fmt::Debug;")?;
    writeln!(f)?;
    writeln!(f, "// Placeholder for Object; replace with a proper enum for real use.")?;
    writeln!(f, "pub type Object = String;")?;
    writeln!(f)?;

    // Emit the enum variants
    writeln!(f, "#[derive(Debug, Clone)]")?;
    writeln!(f, "pub enum Expr {{")?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let fields = parts[1].trim();

        // Build variant with named fields
        write!(f, "    {} {{ ", name)?;
        let field_list: Vec<&str> = fields.split(',').map(|s| s.trim()).collect();
        for (i, field) in field_list.iter().enumerate() {
            let mut it = field.split_whitespace();
            let ty = it.next().unwrap();
            let nm = it.next().unwrap();
            let rust_ty = if ty == "Expr" {
                "Box<Expr>".to_string()
            } else {
                ty.to_string()
            };
            write!(f, "{}: {}", nm, rust_ty)?;
            if i + 1 != field_list.len() {
                write!(f, ", ")?;
            }
        }
        writeln!(f, " }},")?;
    }
    writeln!(f, "}}")?;
    writeln!(f)?;

    // Generate Visitor trait: one method per variant. Decide parameter shapes:
    // For each variant produce a method named visit_<variant>_expr taking each field as a ref.
    writeln!(f, "pub trait Visitor<R> {{")?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let fields = parts[1].trim();
        let fn_name = format!("visit_{}_expr", name.to_lowercase());
        write!(f, "    fn {}(&mut self", fn_name)?;
        let field_list: Vec<&str> = fields.split(',').map(|s| s.trim()).collect();
        for field in field_list {
            let mut it = field.split_whitespace();
            let ty = it.next().unwrap();
            let nm = it.next().unwrap();
            let param_ty = if ty == "Expr" { "&Expr".to_string() } else { format!("&{}", ty) };
            write!(f, ", {}: {}", nm, param_ty)?;
        }
        writeln!(f, ") -> R;")?;
    }
    writeln!(f, "}}")?;
    writeln!(f)?;

    // Implement accept on Expr to dispatch to visitor methods.
    writeln!(f, "impl Expr {{")?;
    writeln!(f, "    pub fn accept<R, V: Visitor<R>>(&self, visitor: &mut V) -> R {{")?;
    writeln!(f, "        match self {{")?;
    for t in types {
        let parts: Vec<&str> = t.split(':').collect();
        let name = parts[0].trim();
        let fields = parts[1].trim();
        let variant_name = name;
        let field_list: Vec<&str> = fields.split(',').map(|s| s.trim()).collect();

        // Build pattern: Expr::Variant { left, operator, right } =>
        write!(f, "            Expr::{} {{ ", variant_name)?;
        for (i, field) in field_list.iter().enumerate() {
            let nm = field.split_whitespace().nth(1).unwrap();
            write!(f, "{}: ref {}", nm, nm)?;
            if i + 1 != field_list.len() {
                write!(f, ", ")?;
            }
        }
        write!(f, " }} => ")?;

        // Call visitor.visit_variant_expr(...), passing references but for Expr fields pass the boxed expr deref.
        let fn_name = format!("visit_{}_expr", variant_name.to_lowercase());
        write!(f, "visitor.{}(", fn_name)?;
        for (i, field) in field_list.iter().enumerate() {
            let mut it = field.split_whitespace();
            let ty = it.next().unwrap();
            let nm = it.next().unwrap();
            if ty == "Expr" {
                write!(f, "&*{}", nm)?; // &*box_expr -> &Expr
            } else {
                write!(f, "{}", nm)?;
            }
            if i + 1 != field_list.len() {
                write!(f, ", ")?;
            }
        }
        writeln!(f, "),")?;
    }
    writeln!(f, "        }}")?;
    writeln!(f, "    }}")?;
    writeln!(f, "}}")?;

    Ok(())
}